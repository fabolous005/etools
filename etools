#!/usr/bin/env bash



# NOTE: parse config, gets run when sourced
function etools_configure() {
	. ./config.sh
	_configure
	./config.sh
}



# NOTE: find a package just by it's name
# the function will go on to print out the most likely result with leading category
function etools_smart_find() {
	[[ "${1}" = *"/"* ]] && echo "${1}" && \
		ewarn "do not use this function with specified category" >&2 && return 0;
	[ "${1}" = "" ] && eeror "no package name provided" && return 2;
	if [ ! "${2}" = "" ]; then
		[ ! -d "${2}" ] && [ ! -d "${ETOOLS_REPO_PATH}/${2}" ] && \
			eerror "no valid repository name" && return 2;
		. ./helper.sh
		if [[ "${2}" == /* ]]; then
			# rely on word splitting for all of these
			# shellcheck disable=SC2046
			_most_probable "$1" $(_filter $(_formatted_find "$@"))
		else
			# shellcheck disable=SC2046
			_most_probable "$1" $(_filter $(_formatted_find "${1}" "${ETOOLS_REPO_PATH}/${2}"))
		fi
	else
		. ./helper.sh
		# shellcheck disable=SC2046
		_most_probable "$1" $(_filter $(_formatted_find "${1}" "/var/db/repos"))
	fi
	# unset helper functions
	./helper.sh
	unset _etools_packages
}


# NOTE: get latest enabled version for a given package name
function etools_get_version() {
	[ -z "$1" ] && eerror "Pass a package name to this function" "\n" && return 2;
	# in this case globs work with -d
	# shellcheck disable=SC2144
	[ ! -d "${ETOOLS_REPO_PATH}"/*/"$1" ] && \
		[ "$ETOOLS_DEBUG" ] && einfo "checked path ${ETOOLS_REPO_PATH}/*/$1" "\n" && \
		[ ! -d /var/db/repos/*/"$1" ] && \
		[ "$ETOOLS_DEBUG" ] && einfo "checked path /var/db/repos/*/$1" "\n" && \
		eerror "Pass a package name to this function" "\n" && \
		return 2;
	
	local latest=:
	. ./helper.sh
	[ "$ETOOLS_CHECK_LIVE" ] && if _matches_live "$1"; then
		# use ls over find for simplicity
		# shellcheck disable=SC2012
		latest="$(ls -1vr "${ETOOLS_REPO_PATH:-/var/db/repos}"/*/"$1"/*9999*.ebuild | head -1 2>/dev/null)"
		[ -n "$latest" ] && _extract_version "$latest" && ./helper.sh && return 0;
	fi
	if [ "$ETOOLS_CHECK_TESTING" ]; then
		. /etc/portage/make.conf
		local arch=:
		arch=$(uname -m)
		if [ "$arch" = "x86_64" ]; then
			arch="amd64"
		fi
		if [[ "$ACCEPT_KEYWORDS" == *"~$arch"* ]] || _matches_testing "$1" "\~$arch"; then
			latest=$(_get_latest "$1" "${2:-${package_offset[$1]:-0}}" "~$arch")
		fi
		[ -n "$latest" ] && _extract_version "$latest" && ./helper.sh && return 0;
	fi
	_get_latest "$1" "${2:-${package_offset[$1]:-0}}" "$arch"

	[ -n "$latest" ] && _extract_version "$latest" && ./helper.sh && return 0;
	ewarn "No version found for package: $1$( (( ! ${2:-${package_offset[$1]:-0}} == 0 )) && echo " with offset $offset")"
}


# NOTE: get currently installed version
function etools_current_version() {
	[ -z "$1" ] && eerror "Pass a package name to this function" "\n" && return 2;
	# for packages with multiple version this errors
	[ ! -d /var/db/pkg/"$1"-[0-9]* ] 2>/dev/null && \
		[ "$ETOOLS_DEBUG" ] && einfo "checked path /var/db/pkg/$1-[0-9]*" "\n" && \
		eerror "Pass a package name to this function" "\n" && \
		return 2;
	local latest=:
	local files_content=()
	. ./helper.sh

	for file in /var/db/pkg/"$1"-[0-9]*/; do
		if [[ -d "$file" ]]; then
			files_content+=("$(<"${file}PF")")
		fi
	done
	[ -z "${files_content[0]}" ] && eerror "Could not find any packages" "\n" && exit 1;
	if [[ -z "$2" ]]; then
		for package in "${files_content[@]}"; do
			_extract_version "$package"
		done
		./helper.sh
	else
		_extract_version "${files_content[$2]}"
		./helper.sh
	fi
}


# INFO: unset all variables
# TODO: move config options to config unset
function etools_unset() {
	for variable in \
		ETOOLS_FIND_CMD \
		ETOOLS_FIND_ARGS \
		ETOOLS_FIND_ARGS \
		ETOOLS_FIND_COMMAND \
		ETOOLS_REPO_PATH \
		ETOOLS_COLOR_INFO \
		ETOOLS_COLOR_WARN \
		ETOOLS_COLOR_ERROR \
		ETOOLS_GREP_CMD \
		ETOOLS_DEBUG \
		etools_configure \
		etools_smart_find \
		etools_get_version \
		etools_current_version \
		etools_unset \
		einfo \
		ewarn \
		eerror;
	do
		unset $variable
		./helper.sh
		./config.sh
	done
}


# INFO: einfo function
einfo() {
    echo -en "${ETOOLS_COLOR_INFO}*\033[0m $*" >&1
}

# INFO: ewarn function
ewarn() {
    echo -en "${ETOOLS_COLOR_WARN}* WARNING:\033[0m $*" >&2
}

# INFO: eerror function
eerror() {
    echo -en "${ETOOLS_COLOR_ERROR}* ERROR:\033[0m $*" >&2
}


# make sure we are being sourced and not executed
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
	etools_configure
else
	ewarn "this is a library do not execute it, source it instead" >&2
	return 2;
fi
